## 알고리즘 개요

### < 기본 개념 >

#### \[ 자료의 이해 및 표현 ]

- **자료**(Data)
	- 단순한 관찰이나 측정을 통해 수집된 사실이나 어떤 값
	- 프로그램을 수행하는 데 필요한 재료
- **정보**(Information)
	- 자료를 특정 목적에 맞게 가공하고 처리하여 실제 문제에 도움이 되는 
	  유용한 형태로 변환한 것
	- 사용자의 요구에 따라 필요한 항목만 추출하고 가공한 자료
- **자료구조**(Data Struct)
	- **데이터의 표현 및 저장 방법**을 의미
	- 컴퓨터에서 자료를 정리하고 조직화하는 다양한 구조
	- 데이터를 **효율적으로 표현**, **저장**하기 **위해 구조화**하는 것
		- 자료가 얼마나 잘 구조화되어 있는냐에 따라 프로그램의 **속도**, **개발시간**, **유지 보수의 비용이 달라짐**
	- 자료를 정돈하는 목적은 프로그램에서 저장하는 데이터에 대해 
	  삽입, 삭제, 검색 등의 **연산을 효율적**으로 위한 것
	- 자료 구조를 설계할 때는 자료와 자료에 관련된 연산들을 함께 고려해야 함

#### \[ 알고리즘의 이해 ]

- ##### 알고리즘(Algorithm)
	- 9세기경 수학자 알콰리즈미(Al Khwarizmi)에서 유래
	- **어떤 문제를 해결하기 위해 구성된 일련의 절차**
		- 어떤 **작업을 수행**하기 위해 **입력을 받아 원하는 출력**을 **만들어내는 과정**을 
		  기술한 것
		- **작업을 수행**하는 **방법을 정의**하는 **단계들의 집합**
- 수학에선 문제를 풀기 위해 정의나 정리들을 활용하는 데 비해 **컴퓨터에서는 알고리즘을 이용**
- 문제의 복잡성에 따라 컴퓨터 프로그램을 통해 문제를 해결할 수 있으며 알고리즘은 컴퓨터 프로그램을 작성하는 바탕이 된다.
- 컴퓨터가 어떤 작업을 수행하려면 컴퓨터로 하여금 해야 할 일을 정확하게 지시하는 
  알고리즘이 주어져야 한다
- 알고리즘은 자료구조와 함께 프로그램 개발의 가장 근본이 되는 학문 분야 중 하나
	- 자료구조가 자료를 효율적으로 저장하는 방법을 알려준다면 자료 구조를 바탕으로 프로그램이 효율적으로 동작하는 방법을 알려준다
- 알고리즘 실생확 적용 예시
	- 네비게이션
		- 두 지점 간의 최단 거리나 최단 시간이 걸리는 경로를 찾아주는 최단 경로 알고리즘
	- 제조공정
			- 작업의 선 $\cdot$ 후 관계가 존재하는 경우 위상 정렬 알고리즘 적용 가능 
- 알고리즘 설계 시 먼저 해야할 작업을 명확하게 명시해야 함
	- 설계하려는 알고리즘이 무엇을 하는지를 입력과 출력으로 명시할 수 있어야 한다
- ##### 알고리즘의 조건
	- 입력
		- **0개 이상**의 데이터 입력
	- 출력
		- 적어도 **하나 이상**의 결과를 출력
	- 명확성
		- 각 단계와 명령은 **모호하지 않고 명확**
	- 유한성
		- 유한한 단계를 거친 후에는 **반드시 종료**해야 한다
	- 유효성
		- 각 명령어들은 **실행 가능해야** 한다

#### \[ 알고리즘의 표현 방법 ]

- 알고리즘은 자연어, 순서도, 의사 코드, 프로그래밍 언어를 사용하여 기술 할 수 있다.
- ##### 자연어
	- 한국어, 영어, 일어처럼 사람이 의사소통을 위해 사용하는 언어
	- 알고리즘을 자연어로 기술하여 사람이 사용하는 문장으로 설명할 수 있다.
	- 자연어로 알고리즘을 기술하면 쉽게 읽고 이해할 수 있다.
	- 사용하는 단어들을 정확하게 정의하지 않으면 내용이 모호해 질 수 있다
		- 명령어로 쓰이는 단어들을 명백하게 정의해야만 알고리즘이 될 수 있따.
	- 자연어 작성 시 알고리즘 기술 내용이 길어져 복잡한 알고리즘을 기술하기엔 적절치 않아
		
	- ex) 배열 A 에서 최고점을 찾는 알고리즘 기술
		- `max_score(A, n)`
		  `배열 A의 첫 번째 요소를 변수 tmp 에 복사`
		  `배열 A의 다음 요소들을 차례대로 tmp 와 비교하여 더 크면 tmp로 복사`
		  `배열 A의 모든 요소를 비교했으면 tmp 반환`
- ##### 순서도
	- 어떤 문제를 해결하는 데 필요한 작업들을 도형들의 관계로 표현하는 방법
		- **문제 해결 과정**을 **기호와 도형을 사용**하여 **표현**하는 방식
		- 기호와 도형을 사용해 문제나 **일의 논리적 흐름을 표현**한 것
	- 과정과 절차를 순서대로 나타냈다고 해소 '순서도' 라 불림
		- 일을 하거나 프로그래밍하는 순서를 알 수 있게 해줌
	- **명령들의 순서대로 도표를 나열**, 작업들의 **흐름 관계를 화살표**로 표현
	- 순서도를 이용하면 알고리즘을 **가시적이고 직관적**으로 표현할 수 있어 알고리즘을 
	  이해하기 쉽다
	- ISO 에서 정한 기호를 사용
		- ![[Pasted image 20250824195933.png]]
	
	- 순서도 예시
		- ![[Pasted image 20250824200033.png]]
- ##### 의사코드(Pseudo code)
	- **프로그램 코드와 유사한 형식**을 가지며 잘 정의된 문장 구조를 사용
	- (pseudo: 허위의, 가짜의) 말 그대로 흉내만 내어 알고리즘을 써놓은 코드
		- 실제 프로그래밍 언어처럼 컴퓨터에서 직접 실행할 수는 없다
	- 알고리즘을 작성할 때 **어떤 문법 환경**에서도 **통용되는 코드를 위해 사용**됨
	- 프로그램 명령문 형식을 취하지만 특정한 프로그래밍 언어의 문법을 따르지 않고 각 명령을 사람이 이해하기 쉽게 적당한 뜻을 가진 단어로 나타낸 것
	- 자연어도 아니고 프로그래밍 언어도 아닌 그 중간 단계의 언어
		- 형식적이고 명확한 문장과 제어 구조를 갖추고 있지만 **상세 구현 레벨**까지는 
		  **신경 쓰지 않아도 된다**
	- 알고리즘을 기술하는데 **가장 선호되는 표기법**, 실제 알고리즘을 기술하는데 주로 사용
		
	- 의사코드 예시
		- `max_score(A, n)`
		  `{`
			 `tmp = A[0];`
			 `for i = 1 to n - 1 do`
				 `if tmp < A[i] then`
					 `tmp = A[i];`
			  `return tmp;`
		  `}`
	- 의사코드는 알고리즘의 핵심적인 내용에 대한 표현에만 집중할 수 있다
	- 실제 프로그래밍 언어와 비슷하여 이해하기 쉬움 
	- 프로그래밍 언어의 문법을 따를 필요가 없으며 프로그램을 구현할 때의 여러 가지 
	  문제들을 감출 수 있다
	- **자연어보다**는 더 **체계적**이고 **구조적**인 방법이지만 
	  **프로그래밍 언어보다는** 엄격하지 않으며 **덜 구체적**인 표현 방법
	- 일반적인 프로그래밍 언어의 형태이므로 특정 프로그래밍 언어로 변환하는 것이 용이함
	- **별도의 표준이 존재하지 않음**
	
- ##### 프로그래밍 언어
	- C, C++, JAVA 등과 같은 특정 **프로그래밍 언어를 사용**하면 알고리즘을 
	  **가장 정확하게 기술**할 수 있음
	- 실제 구현을 위한 많은 구체적인 사항들을 포함하게 됨
	- **프로그래밍 언어에 대한 이해가 있다 하더라도** 알고리즘의 핵심적인 내용들을 파악하고 **이해하는 데 어려움이 있을 수 있음**

#### \[ 알고리즘의 성능 분석 ]

- 알고리즘의 설계와 분석
	- 해결해야 할 문제가 간단할 땐, 직관적으로 알고리즘 설계가 가능하나, **문제가 복잡해지면 복잡한 요구사항을 반영**해야 함
	- 알고리즘을 설계하는 작업은 여러 전략적인 선택이 필요
		- 해결할 문제의 특성을 이해하고 **적절한 자료구조를 선택**할 줄 알아야 함
		- 하나의 문제를 해결하는 알고리즘은 여러 개가 있을 수 잇지만, 그 중에서 **가장 적합한 알고리즘을 찾는 것이 중요**
		- **프로그램 개발**은 **알고리즘 설계하는 과정** 과 **알고리즘을 표현하는 과정**으로 구성
		- 알고리즘 설계시 **명확하고 효율적 설계**
			- 알고리즘을 명확하게 작성해야 한다고 해서 특정한 프로그래밍 언어의 문법에 맞춰야 하는 것은 아님
				- **구조화된 알고리즘을 프로그래밍 언어로 '구현'하는 거지, 특정 프로그래밍 언어로 알고리즘을 '구조'를 작성하는 게 아닌 것을 인지할 것**
			- 절차를 이해할 수 있을 만큼 구체적이되, 불필요한 코드 수준 세부사항은 배제
		- 특정 프로그래밍 언어로 변환하는 데 어렵지 않을 정도
	- ##### 프로그램 작성 위한 단계
		- 문제 분석 (요구사항 분석)
		- 문제 해결 위한 알고리즘 설계 및 기술
		- 프로그램 코딩
		- 프로그램이 정확한지 테스트
		- 프로그잼 수정 및 유지보수
		- ![[Pasted image 20250919072200.png]]
			
		- ##### 문제분석
			- 주어진 문제에 대한 논리적 분석을 통해 핵심 사항들을 분석
			- 프로그램 목적, 사용자, 입$\cdot$출력, 데이터 처리에 관한 요구사항 등을 분석, 
			  구현상의 문제 분석, 타당성 조사 등 **전 과정에 대해 분석 필요**
			- 도메인 관련 필요한 지식 분석 및 숙지
		- ##### 알고리즘 설계
			- 주어진 문제에 대한 알고리즘을 설계하고 분석 및 적용
				- 다양하고 복잡한 절차를 통해 문제를 해결하는 과정
			- 문제에 대한 단계적인 해결책이나 설명, 지시 사항들을 설계
			- 문제 해결 과정을 여러 단계로 나누고, **각 단계를 잘 수행하기 위한 여러 기술들을 적용**
			- 자신이 알고 잇는 기술 직접적 적용 가능한 단순한 문제 외에 어려운 문제는 **다양한 방법을 시도해 보면서 답안을 찾아야 함**
			- 알고리즘 설계 시 '의사코드' 나 '순서도' 를 사용해서 프로그램의 논리적인 실행 순서와 내용을 구체화함
			- 좋은 알고리즘인지 평가하는 기준 중 **큰 문제의 경우 계산량이 문제의 크기와 어떤 관계가 있는지 평가**하는 것
				- 10개의 데이터와 1억 개의 테이터를 동일한 순서, 동일한 계산량으로 취급할 순 없음
				- 문제가 커지고 처리할 데이터의 양이 증가하면 계산량 또한 증가하게 됨
		- ##### 프로그램 코딩
			- 적절한 프로그래밍 언어를 선택해서 구문에 맞는 프로그램 작성
			- 적당한 프로그래밍 언어를 선정하는 것이 중요
			- 수학적 문제 해결이나 통계 처리에 유용한 언어인지, 데이터 처리에 유용한 언어인지 등을 판단하여 선택
		- #####  프로그램 시험 실행
			- 프로그램 테스팅 과정
			- 프로그램 디버깅과 실질적인 데이터와 실질적인 사용자에 의한 시험 실행이 이에 해당
		- ##### 프로그램 문서화/유지보수
			- 하드웨어와 소프트웨어 요구사항, 입출력 프로그램 파일 관리 등 전체적인 사용 설명서를 작성
			- 프로그램의 효과적인 사용을 위한 유지보수
	
- 알고리즘 설계 기법
	- #### 분할 정복(divede and conquer)
		- 그대로 해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 방법
			- 작은 문제를 해결해 나간 뒤 그 해답들을 통합하여 본래의 문제를 해결하는 방법
			- 해결하려는 문제를 크기가 보다 작은 여러 개의 부분 문제로 분할
			- 크기가 작은 부분 문제에 대한 답으로부터 원래의 문제에 대한 해답을 쉽게 얻을 수 있게 분할
			- 분할(divede),  정족(conquer), 결합(combine) 과정을 거침
	- ##### 동적 계획법(dynamic programming)
		- 문제를 여러 개의 하위 문제로 나누어 푼 다음 그것을 결합하여 최종적인 목적에 도달하는 방법
			- 각 하위 문제의 해결을 계산한 뒤 그 해결책을 저장하여 후에 **같은 하위 문제가 나왔을 경우 그것을 간단하게 해결** 할 수 있음
			- 분할 정복과 유사하나, 동적 계획법의 부분 문제들은 의존적 관계가 존재하지만, 분할 정복은 서로 독립적인 관계를 유지함
				- 작은 문제로 분할 시 동적 계획법은 하위 문제들이 중복된 문제들이 없으나, **동적 계획법은 작은 문제들이 중복되는 문제들이 존재**함 
				- ex)병합 정렬 vs 피보나치
				- 프로그래밍 적으론 **같은 입$\cdot$출력**을 하는데 매번 연산을 하려는 것은 불편하니 메모이제이션이라는 기법을 도입해서 동일 연산을 줄임
	- ##### 탐욕 기법(greedy strategy)
		- 기법론이지만 탐욕 알고리즘으로 혼용해서 부르기도 함(greedy algorithrm)
		- 선택해야 할 방법이 여러 가지일 때 현재 상황에서 가장 최선인 것을 먼저 선택하는 기법
			- 여러가지 중 하나를 결정해야 할 때마다 '그 순간'에 최적이라고 생각되는 것을 선택해 나가는 방식을 통해 최종 해답에 도달
			- 언제나 최적해를 구한다는 보장은 없음
	- ##### 백트래킹(backtracking)
		- 역추적을 의미, 우선 어떤 하나의 가능한 경우를 확인하고 가능하지 않다면 다시 되돌아가고, 다시 다른 가능성이 있는 경우를 확인해감
			- 이러한 과정을 결과가 도출될 때까지 계속 반복
			- 일반적으로 백트래킹 알고리즘의 구조 특성상 재귀 함수를 사용하여 구현
	
- 알고리즘의 복잡도
	- ##### 계산 복잡도
		- 현대의 컴퓨터는 매 초 수 백만 개의 명령을 실행할 수 있으나, 효율성은 여전히 알고리즘 설계에서 중요한 사항
		- 하나의 문제를 해결하는 알고리즘이 여러 개 일지라도, 이 중 효율적인 알고리즘과 비효율적인 알고리즘이 존재
			- **알고리즘 선택에 따라** 문제에 대한 **실용적인 해결 방법을 얻는 정도가 달라**짐
		- 따라서 알고리즘들의 성능 비교가 필요
			- **알고리즘의 성능 분석**은 사용되는 **데이터의 형태나 시스템의 성능 등**에 따라 **공평한 결과가 나오기 힘들고**, **비교 결과가 항상 일정하지 않을 수도 있음**
			- 문제의 규모가 커지면 경로의 수나 계산량도 막대하게 늘어남
		- **크기가 충분히 큰 문제는 알고리즘의 효율성이 중요**함
			- 비효율적인 알고리즘 적용은 치명적
			- 크기가 작은 문제는 알고리즘의 효율성이 중요하지 않으며 비효율적인 알고리즘도 무방
		- 대상이 되는 것은 '**입력의 크기가 충분히 클 때**'
			- 충분히 큰 입력에서는 알고리즘의 효율성에 따라 수행 시간 차이가 크게 발생
			- 같은 문제를 해결하는 데 1분이 걸리는 알고리즘과 100 년 걸리는 알고리즘 존재
		- ##### 점근적 분석(anymptotic analysis)
			- 점근적(漸近的)
				- 어떤 값이 **특정 값이나 상태에 점점 가까워지지만, 결코 도달하지 않는** 상태 (google)
				- 기존에는 멀리 있어 보이는 결과물이 근삿값에 점점 **가까워지고 있는 상태**를 말한다 (naver)
				- 복잡도 계산 시 제일 높은 차수를 통해서만 적용될 수 있는 특정 패턴과 유사해지는 구간
					- 상수값의 영향력이 거의 없어지는 구간
					- 패턴 양상으론 비슷하지만, 계산 결과로는 딱 떨어지지 않기 때문에 유사하다고 표현
			- 입력이 충분히 큰 경우에 대한 분석
			- 각 알고리즘이 **데이터의 크기에 따라 수행 시간이나 사용 공간**이 **얼마나 되는지**를 **객관적으로 비교**할 수 있는 **기준**을 제시
			- 두 알고리즘의 속도 비교하는 가장 직관적인 방법은 각각을 **실제 프로그램으로 구현**한 뒤 같은 입력에 대해 **두 프로그램의 수행 시간을 측정**하는 것
				- **현실적으론 유용**한 방법
				- 이론적으론 아무리 빨라도 사용자가 느끼기에 너무 느리다면 소용없음
				- 그러나 사용한 프로그래밍 언어나 하드웨어, 운영체제나 컴파일러 등 수많은 요소에 의해 실행 시간이 바뀔 수 있음
					- **환경에 따라 정도의 차이가 발생**할 수 있음
				- 환경을 제어하더라도, **어떤 문자열 구현을 사용했는지, 함수 인자를 어떻게 넘겼는지 등의 사소한 문제**에 따라 **프로그램의 최종 수행 시간은 크게 달라질 수 있음**
					- ex) JAVA
						- `String`을 쓰면 → 반복적인 문자열 덧셈이 매우 느려짐.
						- `StringBuilder`를 쓰면 → 같은 작업이 수십 배 이상 빨라짐.
						- `StringBuffer`를 쓰면 → `StringBuilder`보다 조금 느리지만, 멀티스레드 환경에서는 안전.
			- **알고리즘은 언제나 같은 속도로 동작하는 것이 아닌 입력의 크기나 특성에 따라 수행 시간이 달라질 수 있음**
			- **시간 복잡도**
				- 수행 시간 분석 결과
			- **공간 복잡도**
				- 메모리 사용량에 대한 분석 결과
			- **최적의 알고리즘**
				- 메모리를 적게 사용, 속도도 빠름
				- **일반적으로** 알고리즘 평가 시 **메모리 사용량보단 실행 속도에 초점**
					- 대게는 속도에 관심이 더 낳고 중요한 요소로 판단
					- 특정 알고리즘에 대해서 상대적인 우월성을 입증해야 하는 경우 메모리의 사용량도 함께 고려됨
						- **이미 검증이 끝난 알고리즘의 적용을 고려**하는 경우에는 **속도에 초점**을 두어 적합성 여부를 판단
			- ![[Pasted image 20250919135507.png]]
				- 연산의 횟수가 가장 많이 걸리는 곳이 기준이 됨
			
		- ##### 공간 복잡도(space complexity)
			- 알고리즘의 메모리 사용량에 대한 분석결과
			- 알고리즘이 문제를 해결하기 위해 사용하는 메모리의 크기
				- 바로 처리될 모든 데이터들은 주기억장치에 저장된 상태에서 실핼되고 처리됨
			- 과거에는 메모리 용량이 크지 않았기 때문에 각각의 데이터가 얼마만큼 주기억장치 공간을 차지하는지 확인하는 것이 필요
				- 최근 대용량 컴퓨터가 많아져서 공간 복잡도의 중요도는 크지 않게 생각함
		- ##### 시간 복잡도(time complexity)
			- 알고리즘을 실행시켜 완료하기까지 걸리는 시간
			- 좋은 알고리즘 선별하는 기준 중 하나
			- CPU 를 차지하는 시간이 길어지게 되면, CPU 가 다른 일을 처리하지 못하기 때문에 그만큼 컴퓨터의 효율이 떨어짐
			- 시계로 직접 측정하는 것은 의미없음
				- 처리해야 할 데이터양의 변화에 따라 속도의 증가나 감소 정도를 알아야 하기 때문
				- 조건을 달리하면서 수백 번, 수천 번 실행해가며 시간을 잴 수는 업기 때문
			- **가장 많이 수행되는 연산의 횟수를 통해 계산**
			- 실제 프로그램의 계산량을 예측하는 것은 간단하지 않음
				- 실행하지 않고도 예측하고 싶지만 특히 외부에서 입력을 받아들일 때에 실행하지 않고 예측하는 것은 매우 어려움
				- 실제 프로그램에서는 다수의 처리 과정이 복잡하게 맞물려 구성되어 있음
				- 전체의 계산량을 좌우하는 곳은 어디인지, 계산량을 효율적으로 축소하기 위해서는 어떤 부분을 다시 생각하면 좋은지를 분석하는 것은 쉽지 않은 일
			- **시간 복잡도 측정 방식**
				- **알고리즘 수행 속도 평가 시 알고리즘의 연산 횟수를 센다**
					- 알고리즘을 이루고 있는 **연산들이 몇 번이나 실행되는 지를 숫자로 표시**
				- 실행 시간은 **입력의 크기가 커지면 증가**함
				- **총 실행 시간**은 단위 연산이 몇 번 수행되는 지에 거의 비례하기 때문에 
				  **단위 연산이 수행되는 횟수를 분석**하여 알고리즘의 효율성을 분석
					- 연산 횟수가 적어야 빠른 알고리즘
				- 처리해야 할 **데이터 수 $n$** 에 대한 **연산 횟수의 함수 $T(n)$** 을 구성
					- 그래프를 통해 연산 횟수의 변화 정도를 쉽게 파악 가능
					- ![[Pasted image 20250919142151.png]]
					- 데이터 수 < $n$ 
						-  B 알고리즘 횟수가 적음(빠름)
					- 데이터 수 > $n$
						- A 알고리즘이 훨씬 빨라짐
					- 결과 해석
						- 데이터 수가 적은 경우 B 알고리즘, 반대 A 알고리즘 선택???
							- 실상 도입부의 차이는 큰 차이라고 여기지 않음
							- **데이터 수가 많아짐에 따른 연산 횟수의 증가 정도가 중요**
							- 종합적으론 A 가 훨씬 더 좋은 알고리즘
						- 대게 A 알고리즘 같이 **안정적인 성능을 보장하는 알고리즘**은 
						  B 알고리즘에 비해 **구현 난이도가 높은 편**4
							- **데이터 수가 많지 않고 성능에 덜 민감한 경우**라면 구현의 편의를 위해 B 알고리즘을 선택하기도 함
				- 시간 복잡도는 **산술 $\cdot$ 대입 $\cdot$ 비교 $\cdot$ 이동의 기본적인 연산을 고려**하여 
				  알고리즘 수행에 필요한 연산의 개수를 계산
					- 다음 예시를 통해 조금 더 알아보자 
					  (단, for 루프의 제어 연산은 고려하지 않는 것을 참고)
					- ![[Pasted image 20250919143816.png]]
					- ![[Pasted image 20250919143832.png]]
					- ![[Pasted image 20250919144929.png]]
					- 알고리즘의 수행 시간을 지배하는 것은 **반복문**
						- 대개의 반복문은 입력의 크기에 다라 수행 횟수가 정해짐
						- 일반적으로 알고리즘 수행 시간은 반복문이 수행되는 횟수로 측정
						- 수행 시간에 큰 영향을 주지 않는 **상수 부분은 무시**, 
						  반복문의 **반복 횟수만 고려**
				- 알고리즘 분석 적용되는 경우의 분류
					- #### 최선의 경우(best case)
						- 수행 시간이 가장 빠른 경우
					- ##### 평균의 경우(average case)
						- 수행 시간이 평균적인 경우
					- ##### 최악의 경우(worst case)
						- 수행 시간이 가장 늦은 경우
						- **가장 널리 사용**
							- 계산이 쉬움
							- 응용에 따라서 중요한 의미 가질 수도 있음
						- 최악일 때, 제일 적게 걸리는 시간을 선택
	- ##### 계산 복잡도 표기법
		- 보통 알고리즘의 성능으로 시간을 사용할 때는 시간 복잡도라는 지표 사용
		- 일반적으로 시간 복잡도는 입력의 개수 $n$ 에 대한 상당히 복잡한 수식으로 나타낼 수 있음
			- $n$ 이 커질수록 **차수가 가장 큰 항의 영향이 절대적**이 되고 다른 항들은 무시될 수 있도록 작아짐
		- 점근적 분석은 데이터 개수 **$n$ 이 무한대가 될 때, 수행 시간이 증가하는 증가율로 시간 복잡도를 표현**하는 기법
		- **점근적 표기법
			- ##### big-O(빅-오) 표기법
				- **아무리 많이 걸려도 이 시간 안에는 끝날 것이라는 개념**이 가장 중요
				- **처리에 필요한 시간의 최대치**를 나타내는 것
				- **성능의 상한**(upper bound)을 나타냄
				- 주어진 알고리즘의 **성능이 아무리 나빠도 big-O  표기의 함수**보다는
				  좋으며 시간이 적게 걸린다는 의미
					- worst case
				- 정의
					- $f(n)$ 과 $g(n)$ 이 주어졌을 때, 모든 $n \geq n_0$ 에 대하여 
					  $f(n) \leq Cg(n)$ 을 을 만족하는 상수 $C$ 와 $n_0$ 가 존재하면
					  $f(n) = O(g(n))$ 이다.
				- **f(n) 은 O(f(n)의 최고차항) 을 넘지 않는다
				- ![[Pasted image 20250919215707.png]]
					
				- 빅-오 표기법의 연산 시간 크기 순서
					- $O(1)$ < $O(log_n)$ < $O$(n) < $O(nlog_n)$ < $O(n^2)$ < $O(n^3)$ < $O(2^n)$ < $O(n!)$
				- 빅-오 표기법의 각 연삭 크기 정리
					- $O(1)$
						- **상수시간**(constant time)
						- **상수형 빅-오**
						- **데이터 수와 상관없이 연산 횟수가 고정인 유형의 알고리즘**
						- 입력값 $n$ 이 주어졌을 때 알고리즘이 문제를 해결하는데 오직 한 단계만 거침
						- 연산 횟수가 데이터 수에 상관없이 3회 진행되는 알고리즘일지라도 $O(3)$ 가 아닌 $O(1)$ 이라 한다.
							- **동일한 상수 레벨**이기 때문에, 베이스 값인 1을 사용
							- **1** x 1 <=> **1** x 3
					-  $O(log_n)$ 
						- **로그 시간**(logarithmic time)
						- **로그형 빅-오**
						- 테이터 수의 증가율에 비해서 연산 횟수 증가율이 훨씬 낮은 알고리즘
						- 매우 바람직한 유형
						- 로그의 밑이 얼마냐에 따라 차이가 나긴 하지만 그 차이는 알고리즘 성능 관점에서 매우 미미함
					- $O$(n)
						- **선형 시간**(linear time)
						- **선형 빅-오**
						- 데이터 수와 연산 횟수가 비례하는 알고리즘
					- $O(nlog_n)$
						- **로그 선형 시간**(log-linear time)
						- **선형 로그형 빅-오**
							- 데이터 수가 2배 늘어날 때 연산 횟수는 2배를 조금 넘가
			- ##### Big-$\Omega$(빅-오메가) 표기법
				- **성능의 하한**(lower bound) 를 나타냄
				- 성능이 아무리 좋아도 빅-오메가 표기의 함수보다는 나쁘며 시간이 많이 거린다는 의미
					- best case
				- 정의
					-  $f(n)$ 과 $g(n)$ 이 주어졌을 때, 모든 $n \geq n_0$ 에 대하여 
					  $f(n) \geq Cg(n)$ 을 을 만족하는 상수 $C$ 와 $n_0$ 가 존재하면
					  $f(n) = \Omega(g(n))$ 이다.
				- ![[Pasted image 20250920001659.png]]
				
			- ##### Big-$\theta$(빅-세타) 표기법
				- **상한과 하한 모두를 동시**에 나타내는 표기법
				- 성능이 아무리 좋거나 나빠도 **빅-세타 함수 사이**에 있다는 것을 의미
				- 점근적 상한과 점근적 하한의 교집합
				- 정의
					-  $f(n)$ 과 $g(n)$ 이 주어졌을 때, 모든 $n \geq n_0$ 에 대하여 
					  $C_1g(n) f(n) \geq C_2g(n)$ 을 을 만족하는 상수 $C_1 \:,\, C_2$ 와 $n_0$ 가 존재하면
					  $f(n) = \theta(g(n))$ 이다.
				- **점근적 표기법 중 가장 정밀한 것은 빅-세타 표기법**
					- 실질적으론 빅-오 표기법을 많이 사용
						- 빠른 알고리즘을 선호하기 때문
						- 성능의 상한은 빠름의 한계
				- ![[Pasted image 20250920005331.png]]