## 절차지향의 개념과 특징

### < 절차지향의 개념 >

#### \[ 절차지향 ]

- **분할과 정복 개념**(시스템을 기능에 따라 분할하여 개발 후 통합)을 이용하여 **프로시저 호출 개념을 기반**으로 **프로그램 전체가 유기적으로 연결**된 것
- 단순히 순서대로 명령을 수행하는 것을 의미하는 것이 아닌, **프로시저의 호출의 개념을 바탕**으로 하는 구조적 프로그래밍의 일종
	- 프로시저의 호출의 순서로 인해 반영되는 결과를 이해하면서 프로그램을 구성해야 됨
	- 프로그램의 어디에서나 프로시저를 호출할 수 있는데, 다른 프로시저에서도 호출이 가능하고 자기 자신에서도 호출이 가능
- 절차는 함수로 해석 가능
- 대표적인 절차지향 프로그래밍 언어
	- **포트란**
	- **베이직**
	- **C 언어** 등
- **유지보수가 어렵고 순서가 엄격**하게 정해져 있음
	- 이런 단점을 보환하기 위해 객체지향 개념이 등장

※ 프로시저란?
- **작업 단위로 묶어놓은 코드 블록**
- **함수**(function), **서브루틴**(subroutine), **메서드**(method, 객체지향에서 주로 사용) 등으로 불림

---
### < 절차 지향의 특징 >

절차 지향은 Top-Down 방식이며, 함수 호출등의 특징을 가지고, **실행 순서** 또는 **철차**에 더 **중점**을 둠
- **Top-Down**
	- 하나의 큰 기능을 처리하기 위해 작은 단위의 기능들로 나누어 처리하는 방식
- **함수호출**
	- 비교적 작은 규모의 작업을 수행하는 함수를 생성하여 인수와 반환값(value)으로 명령을 전달하고 수행
- **데이터와 함수 분리**
	- 데이터와 함수를 별개로 구분하여 특정 기능을 수행하려면 그 일을 해주는 함수를 직접 호출해야 함

---
### < 절차지향과 객체지향 비교 >

#### \[ 설계 방식의 차이 ]

- ##### 절차지향
	- **프로그램 순서와 흐름을 먼저 계획**하고 자료구조와 함수를 설계
	- **기능을 호출**하여 데이터에 접근하고 업무를 처리
- ##### 객체지향
	- 실제 서비스를 이루는 **메소드와 데이터를 중심으로 설계**
	- **기능과 데이터로 묶어 캡슐화**시킨 후 메시지는 전달하여 업무를 처리

![[Pasted image 20250904182056.png]]

# ----------------------------------------------------------

## 객체지향의 개념과 특징

### <객체지향의 개념 >

- 객체지향에서는 현실 세계의 개체를 속성과 메소르가 결합된 형태의 객체로 표현
- 현실 세계에 존재하는 실체 및 개념들을 객체(Object)라는 독립된 단위로 구성
	- 이 객체들이 메시지 교환을 통해 상호작용함으로써 전체 시스템이 운용되는 개념
	- 원조격 객체지향 언어(Smalltalk, Objective-C 등)에서는 메시지 개념이 **문법적으로 명시**되어 있다.
	- 현대의 주류 객체지향 언어(C++, Java, Python 등)에서는 메시지 전달이 **함수/메서드 호출**로 단순화되어, 메시지와 호출을 뚜렷하게 구분하지 않는다.
- 객체지향이 등장한 이유는 전통적인 개발 방법론의 문제점인 저품질 및 개발 생산성의 저하가 발생함으로 인해 **재사용 및 확장성 증대가 필요**
- **SW 위기를 극복하기 위해** 객체지향이 사용되면서 **재사용 $\cdot$ 유지보수성을 높여 공정들 단축**하고 고품질 제품을 개발하기 위해 많이 사용
- ![[Pasted image 20250904183446.png]]

---
### < 객체 지향의 특징 >

#### \[ 캡슐화(Emcapsulation) ]

- **데이터 및 클래스를 하나로 묶어**, 객체 **내부에서 필요로 하는 정보**를 **외부로부터 은닉**
	- **메소드를 통해 접근**하여 **한 번에 관리**할 수 있게 해준다.

#### \[ 정보 은닉(Information Hiding) ]

- **캡슐화에서 가장 중요**한 개념
- 다른 객체에게 **자신의 정보를 숨기고 자신의 연산만을 통하여 접근**을 허용한다

#### \[ 추상화(Abstraction) ]

- **외부 인터페이스만 제공**하고, 객체 내부를 숨겨서 **어떻게 일을 하는지 몰라도 원하는 결과를 얻을 수 있다**

#### \[ 다형성(Polimorphism) ]

- **메소드명은 같더라도** 매개변수의 개수, 매개변수의 유무, 매개변수의 자료형 등에 따라 **다른 메소드가 실행**된다.

#### \[ 상속(Inheritance) ]

- **상위 클래스**에 정의되어 있는 기능을 **하위 클래스에서 물려받아 사용**할 수 있다.

---
### < 클래스와 객체 >

#### \[ 클래스 ]

- 현실 세계의 객체 집합에서 공통된 속성과 행동을 추출하여 모델링한 **논리적 집합체**
- 객체를 정의하고 생성하기 위한 **템플릿**

#### \[ 객체 ]

- 현실 객체를 모델로 하여 소프트웨어적으로 구현된 객체지향 언어의 기본 단위
- 현실 객체를 추상화하여 **도메인 관심 영역의 속성과 메소드를 캡슐화**함

![[Pasted image 20250904184731.png]]

#### \[ 클래스와 객체의 용도 ]

- ##### 클래스
	- 객체를 **정의**해 놓은 것
	- 객체의 **설계도**
	- 객체를 생성하는 데 사용
	- 특정 객체를 생성하기 위해 변수와 메소드를 정의하는 **일종의 틀**
	- 객체를 정의하기 위한 **멤버변수와 메소드로 구성**
- ##### 객체
	- **실제로 존재하는 사물**
	- 객체가 가지고 있는 기능과 속성에 따라 다르다
	- 클래스로 규정된 **인스턴스**로 **변수 대신 실제 값을 가진다**
	- 현실 세계의 실체 및 개념을 반영하는 멤버변수와 메소드를 정의한 **데이터의 집합**
	
- 클래스를 통해 객체를 생성하는 것은 설계도를 통해서 제품을 만드는 과정과 동일
	- ![[Pasted image 20250904185441.png]]

#### \[ 클래스의 구조와 관계 ]

- ##### 클래스의 구조
	- 클래스 표기는 박스를 세 부분으로 분리
		1. 제일 상위는 클래스 이름
		2. 가운데는 속성
		3. 연산(메소드)를 기술
		- ![[Pasted image 20250904185631.png]]
	
	- 구성요소
		- ##### Name
			- 클래스 이름 표시
			- **이텔릭체는 Interface** 를 의미
		- ##### Attribute
			- 클래스의 Property 에 이를 대표하는 짧은 명사나 명사구로 이름을 붙인 것
		- ##### Operation(Method)
			- 객체 행동에 영향을 주기 위해 특정 class 의 객체로부터 요청할 수 있는 서비스를 표현
			- Class 인터페이스의 일부
	- 표기법
		- ##### 접근성 표기법
			- **-** : Private (해당 클래스 내에서만 접근 가능)
			- **\#** : Protected (동일 패키지 내에서만 접근 가능)
			- **+** : Public (어디서든 접근 가능)
		- ##### 명칭 표기법
			- **Attribute** : 의미있는 명사형으로 표시
				- 예시) +variableName : byte
			- **Operation** : 의미있는 동사형으로 표시
				- 예시) +createMethodName(int parm) : int
	- 클래스는 속성(Attribute)과 연산(Opreation)으로 구성
	
- **클래스간 관계**
	- 유형
		- ##### 일반화 관계(Generalization)
			- 상위와 하위의 관계를 의미
			- 하위는 상위의 **공통점을 상속** 받아 가짐
			- 표기법
				- ![[Pasted image 20250904205219.png]]
			- `class A {}`
			  `class B extend A {}`
			
		- ##### 연관관계(Association)
			- **한쪽에서 다른 쪽을 사용**하거나 **참조**할 수 있음
			- 표기법
				- ![[Pasted image 20250904205236.png]]
			- `public class Point {}`
			  `public class Circle { 
				  `private Point\[] pointOSP;
				}`
			
		- ##### 집합연관 관계(Aggregation)
			- 클래스와 **클래스간의 부분과 전체의 관계**를 표현
			- 복합연관 관계와는 다르게 전체 클래스가 소멸되도 부분 클래스는 존속
			- 표기법
				- ![[Pasted image 20250904205343.png]]
			- `Class Car {
			  `Wheel wheel;
			  `Car(Wheel whell) {
			  `This.wheel = wheel; }
			  `}
			  `Wheel wheel = new Wheel();
			  `Car car = new Car(wheel)`
			
		- ##### 복합연관 관계(Composition Aggregation)
			- 부분과 전체 관계이나, **전체 클래스 소멸 시 부분 클래스도 소멸**
			- 표기법
				- ![[Pasted image 20250904205359.png]]
			- `Class Company {
			  `Department department
			  `Company(Department department) {
			  `This.Department = department; }
			  `}
			  `Department department = new Department
			  `Company company = new Company(departmet)`
			
		- ##### 의존관계(Dependency)
			- **오퍼레이션의 매개변수나 리턴 타입으로 사용**될 때
			- 의존성 주입 시 사용
				- 생성자 주입, 메소드 주입 등
			- 표기법
				- ![[Pasted image 20250904205609.png]]
			- `class A {
			  `void method(B b)
			  `}
			  `}
			  `class B {}`
			
		- ##### 실체화 관계(Realization)
			- **인터페이스와 그것을 구현한 클래스**의 관계
		- 표기법
			- ![[Pasted image 20250904205634.png]]
		- `interface A {}
		  `class B inplements A {}

##### \[ 클래스 선언 방법 ]

![[Pasted image 20250904205920.png]]

##### \[ 객체 구성 ]

- ##### 인스턴스
	- 어떤 클래스로부터 만들어진 객체
- ##### 인스턴스화
	- 클래스로부터 객체를 만드는 과정
- ![[Pasted image 20250904210128.png]]
- **객체는 속성과 기능**으로 이루어져 있고 이를 **멤버 변수와 메소드**라고 부른다
	- ![[Pasted image 20250904210219.png]]
- 멤버 변수와 메소드를 선언하는 데 순서는 관계없지만, 일반적으로 멤버변수를 먼저 선언한다

---
### < 변수와 메소드 >

#### \[ 변수 ]

- **데이터를 저장**하기 위해 프로그램에 의해 **이름을 할당받은 메모리 공간**
- **변수의 종류를 결정**하는 중요한 요소는 변**수가 선언된 위치**와 관련이 있다
- ##### 인스턴스 변수
	- 인스턴스 생성될 때 **독립적인 저장공간**을 가짐
	- 같은 클래스에서 받더라도 각 **인스턴스의 별개 메모리**로 가지는 변수
- ##### 클래스 변수
	- 모든 인스턴스가 **공통된 저장 공간**을 공유
	- Static 변수 같이 **단일 메모리 공간**
- ##### 지역 변수
	- 메소드 내에 선언되어 **메소드 내에서만 공유**

#### \[ 메소드 ]

- **특정 기능을 수행**하는 코드들의 집합
- 어떤 값을 입력하면 해당 값을 기반으로 작업을 수행하여 원하는 결과 값을 반환
- ##### 인스턴스 메소드
	- **인스턴스가 반드시 존재**해야만 사용
	- 객체를 통해서만 호출 가능
- ##### 클래스 메소드
	- **모든 인스턴스에 공통**으로 사용하는 함수에 사용
	- 객체 없이 클래스 자체만으로도 호출이 가능

![[Pasted image 20250904211610.png]]

---
### < 캡슐화와 정보은닉 >
#### \[ 캡슐와화 정보은닉의 개요]

- ##### 캡슐화
	- 관련된 기능을 가진 **변수와 메소드를 묶어**서 관리하기 쉽게 해주는 기법
	- 개념
		- 속성과 메소드, 데이터와 기능의 집합
	- 목적
		- 관계있는 데이터나 함수를 하나로 모음
	- 기법
		- class
	- 장점
		- **코드의 재사용성 향상**
		- **유지보수 용이**
		- **객체 간 종속성 최소화**
- ##### 정보은닉
	- 복잡하거나 변경 가능한 부분을 캡슐 내부에 감추고, **외부에는 추상화되고 변경 가능성이 낮은 인터페이스만 제공**하는 **객체지향 핵심원리**
	- 개념
	- 목적
		- 캡슐화된 코드의 보호
	- 기법
		- public, private, protected
	- 장점
		- **소스 코드 및 데이터의 무결성 향상**
		- **개발 생산성 향상**
	- 정보은닉시 클래스 혹은 메소드는 private, protected, public 으로 지정이 가능하다
- ![[Pasted image 20250904212522.png]]

#### \[ 접근 지정자별 기본 클래스 접근 범위 ]

- 접근 지정자는 private, protected, public 으로 구분
- ##### private
	- 파생 클래스에 상속되지 않기 때문에, 기본 클래스의 멤버 함수만 참조가 가능
- ##### protected
	- 파생 클래스에 보호 멤버로 상속되고 클래스 외부에서 참조는 불가능
- ##### public
	- 파생 클래스에 상속되기 때문에 파생 클래스에서 참조 가능
- ![[Pasted image 20250904213905.png]]

---
### < 상속과 다형성 >

##### \[ 상속 ]

- 하위 클래스가 상위 클래스의 속성과 메소드를 재정의하지 않고 그대로 사용 가능한 속성
- 부모 클래스의 속성을 물려받아서 자식 클래스에서 동일하게 사용하는 것이 가능
- 특징
	- 컴파일 시 **정적으로 바인딩**
- 장점
	- **확장성 및 재사용성** 제고
- 단점
	-** 과도한 상속은 결합도 상승**의 원인
- 기법
	- class
- 유형
	- **단일 상속**
	- **다중 상속**

#### \[ 다형성 ]

- **서로 다를 객체**가 **동일한 메시지**에 대해 **고유한 방법으로 응답**할 수 있는 속성
- **다른 클래스 이름이지만 같은 이름의 메소드**를 가지게 되는 경우 동일한 이름의 메소드라도 **그 메소드에 일어나는 클래스에 따라 각기 다른 행동**을 수행
- 특징
	- 런타임 시 **동적으로 바인딩**
- 장점
	- **개발생산성, 유지보수성, 재사용성, 확장성, 유연성**이 좋음
- 단점
	- **가독성 저하**로 디버깅이 어려움
	- **중복 코드 개발 가능성**이 높음
- 기법
	- public, private, protected
- 유형
	- **오버라이딩**
	- **오버로딩**
- ![[Pasted image 20250904214938.png]]

#### \[ 상속과 다형성 적용 시 선택사항 ]

- 상속과 다형성을 적용하기 위해서는 현재 설계구조와 모델링을 고려하여 어떤 방식이 더 타당한지 확인 후 적용
- 선택사항
	- 상속 적용시 선택사항
		- ##### is - a 관계
			- 1 : 1
			- 상속을 사용
		- ##### has - a 관계
			- 1:1, N:1, 1:N
			- 위임을 사용
		- 같은 클래스의 다른 구현이 존재하거나 복수의 슈퍼 클래스 존재 시 상속보다 위임을 사용
		
	- 다형성 적용시 선택사항
		- ##### Type Casting
			- 하위 클래스를 상위 클래스로 강제 형변환
		- ##### Genericity
			- 클래스 자체를 파마미터화
		- ##### Operator Overloading
			- 연산자 오버로딩
			- 연산자도 하나의 함수라는 개념을 사용하여 중복 정의

#### \[ 상속 상세설명 ]

- 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
- 상속을 통해 클래스를 작성하면 코드를 공통적으로 관리하는 것이 가능하여 신규 소스 추가 및 변경이 유용
- 상속 표현 방법
	- ex) 클래스 이름 : Child, 상속자 : Parent
		- ![[Pasted image 20250904220337.png]]
	- Parent 에서 name 이라는 멤버 변수를 추가할 경우, Child 클래스는 Parent 클래스 멤버를 상속받기 때문에 Child 클래스에는 자동적으로 name 멤버 변수가 추가됨
- ##### 다중 상속
	- 하위 클래스가 2개 이상의 부모 클래스로부터 상속을 받는 것
	- C++ 에서만 지원
	- JAVA 에서는 지원하지 않고 인터페이스만 허용
	- 프로그래밍 언어에 따라 적용방식이 다름
	- ![[Pasted image 20250904220637.png]]
	- 다중 상속시 두 **부모에게 중복되는 멤버 변수**가 있을 때는 **부모를 명시하는 것이 필요**

#### \[ 다형성 상세설명 ]

- 다형성을 통해 추상화된 **클래스의 속성 및 기능을 상속받아 재정의**하여 **동일한 인터페이스**를 갖지만 **행위는 다양하게 구현**하는 것이 가능
- 런타임에서 인터페이스가 일치하는 다른 객체로 대체되어 **런타임 객체에 따라서 연산 수행 결과가 달라짐**
- 다형성의 특징 및 동작 원리
	- **확장성**
		- 하나의 인터페이스에 메소드를 type 및 개수를 변경하여 재정의
	- **유연성**
		- 하나의 인터페이스를 일관성 있게 사용자 중심으로 제공
	- **재사용성**
		- Overloading, Overriding 을 이용하여 재사용성 높임
	- **디자인 패턴에 Prototype** 을 이용하면 **효과적으로 코딩** 가능
	- ![[Pasted image 20250904221335.png]]
	- 오버라이딩 된 메소드라도 **부모 클래스의 이름을 통해서 부모의 메소드로 호출가능**
	
- **다형성의 유형**
	- ##### Oveloading
		- **하나의 클래스 내**에 비슷한 일을 하는 메소드를 **같은 이름의 메소드로 여러 개 정의**하여 사용
		- ![[Pasted image 20250904221909.png]]
		
	- ##### Overriding
		- **상속 관계에 있는** 두 클래스 중 **하위 클래스에서 상위 클래스의 메소드를 재정의**하여 사용
		- ![[Pasted image 20250904222351.png]]

##### \[ OOP 설계의 5대 원칙 ]

- OOP 설계의 5대 원칙의 개요
	1. 객체 지향 설계의 5개 원칙의 개념
		- 소프트웨어를 설계함에 있어 **이해하기 쉽고, 유연하고, 유지보수가 편하도록** 도와주는 5가지의 원칙
		- 시스템에 **예상하지 못한 변경사항이나 수정**이 발생되더라도 **유연하게 대응**이 가능한 시스템 구조를 만들기 위한 것
		- 시스템에 새로운 요구사항이나 **변경사항이 있을 때 영향을 받는 범위를 최소로 만들어** 신속한 대응을 하기 위함
		- OOP 설계의 5대 원칙은 객체 지향 소프트웨어 설계 도구들의 근본이자 목적이 되는 원칙
	2. 객체지향 설계의 5대원칙의 중요성
		- 재사용성, 유지보수성의 향상을 위해(높은 응집도, 낮은 결합도) 설계 원칙을 기반드로 디자인 패턴 또는 유용한 개발론들이 등장
	3. 객체지향 설계의 특징
		- **품질 향상**
			- 재사용성, 유지보수성, 이식성을 통해 생산성 및 품질 향상
		- **모형의 적합성**
			- 현실 세계 및 인간의 사고 방식과 유사
		- **일관성**
			- 전체 공정에서 각 단계간의 전환과 변경이 자연스럽고 신속함
- 객체지향 개발절차
	- 기획
		- 문제 정의
		- 개발 계획
	- 분석
		- ##### 객체 모델링
			- 클래스 실별
			- 속성과 Interface 정의
			- 계층 구조로 객체 모델들 조직화
		- ##### 동적 모델링
			- 시나리오와 이벤트 정의 및 작성
			- 이벤트 흐름도 및 상태도 작성
		- ##### 기능적 모델링
			- I/O 식별
			- 프로세스와 제약사항, 최적화 필요사항 등을 정의
	- 설계
		- ##### 시스템 설계
			- 설계 목표 정의
			- 서브시스템 파악
			- 자료저장소 설계
			- 시스템 구조 설계
		- ##### 객체 설계
			- 객체 정의
			- 자료구조와 알고리즘 구현
	- 구현 & 테스트
		- 구현
		- 테스트/검증
		- 코딩과 테스트
			- 객체 및 클래스를 객체지향 언어로 구현
			- 절차적 프로그램의 테스트와 유사
	- 인수/설치
		- 통합테스트
		- 인수테스트
		- 프로젝트 평가
	
- 객체 지향 설계의 5대 원칙(S$\cdot$O$\cdot$L$\cdot$I$\cdot$D)
	- ##### 단일 책임의 원칙(SRP: Single Responsibility Principle)
		- **객체는 하나의 책임만**을 맡아야함
			- 억지로 나누지 말 것
		- DB 정규화와 비슷
			- 성능저하라는 부작용이 없음
		- 핵심
			- 변화
		- 목적
			- 변화에의 유연성 확보
				- 낮은 결합도, 높은 응집도 추구
		- 사례
			- 데이터 매퍼 패턴(DAO)
	- ##### 개방폐쇄 원칙(OCP: Open Closed Priciple)
		- 모듈은 **확장에는 열려**있어야 하고, **변경에는 닫혀**있어야 함
		- 방법
			- 변하는(확장되는) 결과 변하지 않는 것을 엄격히 구분한 후 이 두 모듈이 만나는 지점에 인터페이스를 정의
		- 사례
			- 상속과 어댑테 클래스를 통한 클라이언트 클래스 접속
			- 컴파일러, POSIX 표준
	- ##### 리스코프치환 원칙(LSP: Listov Substitution Priciple)
		- **기반**(자식) 클래스는 **파생**(부모) 클래스로 **대체 가능**해야 함
			- 인터페이스만 알면 구현체를 몰라도 사용가능해야 함
	- ##### 인터페이스 분리의 법칙(ISP: Interface Segregation Principle)
		- **하나의 일반적인 인터페이스보다**는 **구체적인 여러 개의 인터페이스**가 나음
		- 핵심
			- 변화
		- 목적
			- 변화에의 유연성 확보
		- 효과
			- 인터페이스의 통합과 분리
		- 사례
			- 파일 입력은 Inputinterface, 파일 출력은 Outputinterface
			- 공유 리파지토리 패턴
	- ##### 의존관계 역전의 원칙(DIP: Dependency Inversion Principle)
		- 클라이언트는 구체 클래스가 아닌 인터페이스나 추상 클래스에 의존해야 함
		- Brige 패턴처럼 인터페이스/추상 클래스 간에만 서로 의존 관계를 가지며 참조
		- 모든 클래스에 인터페이스를 생성하면 클래스가 엄청나게 증가하고 복잡해지므로 필요한 것만 생성
		- 사례
			- 이벤트 드리븐
			- 콜백
			- JMS
			- 통신 프로그래밍 모델