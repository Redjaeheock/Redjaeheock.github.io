## 프로그래밍 언어의 역사와 특징


다양한 하드웨어의 실행 목적과 속도, 시간에 따라 따라 프로그래밍 언어가 개발되고, 없어짐
기계어 중심 언어에서 출발해서 현재 인공지능에 사용되는 언어까지 새로운 언어가 출시됨
본 강에선 C, C++, JAVA 언어에 대한 역사와 특징을 살펴볼 예정

### < C 언어의 역사와 특징 >

C 언어가 탄생한 지 40 여 년이 되었지만 여전히 **OS 커널** 및 **미션 크리티컬한 하드웨어 제어 분야**에서 가장 많이 사용됨
B 언어의 다음 언어라는 의미로 C언어라고 붙여짐

#### \[ C언어의 역사 ]

- 탄생 배경
	- 1970 년 초 벨 연구소의 데니스 리치에 의해 개발
	-  UNIX OS 제작시 기존 언어가 성능은 좋지만 하드웨어에 종속적이고 이식성이 떨어졌음
- 고급 언어임에도 불구하고 기계 언어의 **빠른 속도**와 **높은 이식성**을 갖고 있음
- C 언어로 작성하면 **어떤 하드웨어에서도 컴파일 가능**
- 미국의 표준화 기구인 **ANSI** 에 의해 **1980 년대 초반**에 시작
- 국제 표준화기구인 **ISO** 에 의해 **C90 **발표
- 현재는 2011 년에 발표된 최신 **표준 C11** 이 사용되고 있음

#### \[ C언어의 특징 ]

- **다양한 OS** 에서 **쉽게 이식**될 수 있고, **다른 CPU** 를 가지는 **하드웨어**로도 **이식 가능**
- **절차 지향**
	- 프로그램 순서대로(Top - Down) **순차적**으로 **수행**
	- 정해진 순서에 따른 순차적인 처리가 중요
	- **프로그램 전체**가 **유기적으로 연결**됨
- **모듈화**
	- 함수로 구성되어 있는 **함수**(Function)**형 언어**로서 **코드를 간결하게 작성 가능**
	- C언어 개발 전까지의 프로그램은 크기와 관계없이 하나의 파일에 모든 소스코드를 작성했음
	- 소스코드의 크기가 커질수록 관리가 어려워진 부분을 **모듈화를 통해 관리가 용이**해짐
- **직관적인 하드웨어 제어**
	- **기계언어**(어셈블리어) **수준**으로 **시스템 자원**을 **제어**하는 것이 **가능**
	- 기계어와 어셈블리어로 가능한 **하드웨어 제어**를 **C 언어**를 이용하여 **프로그래밍** 
	  하는 것이 가능
---
### < C++ 언어의 역사와 특징 >

C++ 은 C언어의 확장판으로, 문법은 그대로 유지하면서 **객체지향적 언어 기능**을 **추가**한 것
C++ 의 이름음 C 와 ++(증감연산자)에서 가져옴

#### \[ C++ 언어의 역사 ]

- **1980** 년대 후반 **소프트웨어 위기**가 대두되면서 해결책으로 **객체지향 프로그램**이 **제시**됨
	- **하드웨어 속도**는 빨라지나 **소프트웨어** 관련된 **역량과의 차이**가 커지면서 위기 도래
- **1990** 년부터 대형 프로젝트에서 **본격적으로 사용**
- 구조적 프로그램은 재사용과 유지 보수가 어려웠으나. 객체지향 프로그램은 기존에 
  **작성한 코드를 재사용**하여 코딩 **시간을 줄일 수 있었기에 많이 사용**되었음
- **1998** 년 C언어 표준안을 기반으로 ISO 14882 **C++ 표준안 발표**
- 
#### \[ C++ 언어의 특징 ]

- C 언어로 작성된 프로그램을 그대로 사용할 수 있도록 **C 언어의 문법적 체계**를 그대로
  **계승**하여 **호환성**을 유지 
- **C 언어**로 작성되어 **컴파일된 목적 파일**과 **라이브러리**를 **C++ 프로그램에서 링크**하여 사용하는 것이 **가능**
	- **include** 받는 방식이나 **표준 디렉토리 사용**하는 **방식**은 **상이**함
- **객체지향**
	- 재사용을 통해 소프트웨어 생산성을 높일 수 있는 객체지향 개념 도입
- **타입 체크**
	- **타입 체크**를 **엄격히** 함으로써, **실행 시간 오류**의 **가능성을 줄이고 디버깅하는 것**에 **도움**을 줌
	- 명시적 타입체크와 암묵적 타입 체크 중** 명시적 타입 체크를 강화**
- **효율성 저하 최소화**
	- 멤버 함수에 **인라인 함수**를 **도입**하는 등 **함수 호출로 인한 시간**을 **단축**

---
### < JAVA 언어의 역사와 특징 >

JAVA 는 **썬 마이크로시스템즈**(현재는 오라클에 합병)에서 개발한 **객체지향 프로그램 언어**
꾸준히 성능을 개선하여 새로운 버전을 발표하고 있음

#### \[ JAVA 언어의 역사 ]

- 썬 엔지지어들에 의해서 고안
- **오크**(Oak)라는 언어에서부터 시작
- 가전 제품에 탑재될 소프트웨어를 만들기 위해 C++ 언어를 사용하려 했으나, 목적을
  이루기엔 부족한 이유로 **C++ 의 장점을 도입**하고 **단점을 보완**한 새로운 언어를 개발
- Oak 는 처음에는 가전제품, PDA 등 **소형기기**에 **사용될 목적**이었으나 **OS에 독립적**인 
  **Oak** 를 **인터넷에 적합하도록 개발** 방향을 바꾸면서 **JAVA로 변경**
- 1996 년 JAVA 정식 버전 발표

#### \[ JAVA 언어의 특징 ]

- **OS 독립**
	- **OS** 나 **하드웨어**에 **관계없이 실행 가능**하며, **한 번 작성**하면 **어디서나 실행** 가능(Write once, run anywhere)
- **객체지향**
	- 재사용을 통해 소프트웨어 생산성을 높이기 위하여 객체지향 개념을 도입
	- **상속**, **캡슐화**, **다양성 등**의 특징을 가짐
- **자동 메모리 관리**
	- **가비지 콜렉터**가 자동적으로 메모리를 관리해주기 때문에 **프로그래머**는 **메모리를 따로 관리하지 않아도 된다**
- **멀티스레드 프로그래밍 가능**
	- 멀티스레드
		- 하나의 프로그램에서 여러 개의 스레드가 동시에 실행될 수 있는 기능
		- 시스템과 관련 없이 구현 가능 
# ----------------------------------------------------------

## 프로그램 생성과 실행

### < 실행프로그램 생성 절차 >

![[Pasted image 20250823210013.png]]

#### \[ 1단계 - 원시파일 작성 ]

- 편집기로 작성된 프로그램을 원시프로그램(Source Program)이라 함
- 원시 프로그램이 저장된 파일을 원시 파일(Source File)이라 함
- 편집기
	- 이클립스
	- 비주얼스튜디오 등
- 확장자
	- C 언어 = \*.c
	- C++ = \*.cpp
	- JAVA = \*.java
- 작성된 원시 파일 자체로는 실행되지 않음

#### \[ 2단계 - 목적 파일 생성 ]

- 원시프로그램 내부에 # 또는 import 로 시작하는 특별한 지시어를 포함
- 컴파일러가 정상적으로 수행할 수 있는 **선행처리기**(Preprocessor)가 **먼저 수행**되어야 함
- C 언의 경우 \#inlcud. \#define 같은 **헤더 파일**을 **원시 파일에 포함**시켜야 함
- 원시 파일을 컴파일하여 기계어(이진코드)로 번역된 목적파일 생성
- 확장자
	- \*.o (obj)

#### \[ 3단계 - 실행 파일 생성 ]
- 실행 가능한 파일은 **링크 과정**을 거쳐서 만들어짐
	- 링크는 다양한 **목적 파일** 또는 **라이브러리**를 **연결**하여 **실행 가능한 파일**을 **생성**
- 확장자
	- \*.exe

#### \[ 4단계 - 실행 파일의 실행 ]

- 특정 OS 에서 동작하도록 실행 파일을 실행
- C 와 C++ 은 특정 OS에서 실행되도록 환경을 설정해야 함
- JAVA 는 OS 관계없이 가상머신에서 실행

---
### < 컴파일 과정과 컴파일러 구조 > (개인적 노트 내용)

#### \[ 역사적 배경 ]

- C 언어가 만들어질 당시(1970년대 초), **컴파일러 구조를 단순화**하기 위해 
  "전처리 단계"를 별도의 **프로그램(Processor)** 으로 두었음
- 전처리기 (cpp) → 컴파일러 (cc) → 어셈블러 (as) → 링커 (ld)
  처럼 **서로 독립된 프로그램들**이 **파이프라인**으로 **연결된 구조**였음

- C/C++ 컴파일 과정(전통적 구조)
	1. **Preprocessor (전처리기)**
		- `#include`, `#define`, `#if` 등 지시문 처리 → 텍스트 변환.
	    - 별도 실행파일: `cpp`
	2. **Compiler (좁은 의미의 컴파일러)**
	    - C/C++ 소스 → 어셈블리 코드
	    - 문법/타입 체크, 최적화 등 수행
	    - 실행파일 예: `cc1` (gcc 내부의 실제 C 컴파일러)
	3. **Assembler (어셈블러)**
	    - 어셈블리 코드 → 오브젝트 코드(기계어)
	    - 실행파일 예: `as`
	4. **Linker (링커)**
	    - 여러 오브젝트 파일 + 라이브러리 → 실행파일
	    - 실행파일 예: `ld`

---
### < 선행 처리기(in C & C++) >

#### \[ 선행처리기(Preprocessor) 개요 ]

- 전처리 프로그램
- C 와 C++ 언어는 이미 만들어진 함수를 호출하여 사용
	- **이미 만들어진 함수**를 **호출**하는 **명령줄** -> **선행처리기**
- 선행처리기는 공동으로 프로그래밍하거나 대규모 프로그램 제작 시 유용
- C 언어에서 처음 도입
- `#include` 는 다른 파일의 내용을 호출하여 메모리에 기록한 후 새로운 소스코드에서
  호출한 파일의 내용을 사용 가능
#### \[ 선행처리기의 사용 형식 ]

- `#inlcude <파일명>` 
	- 미리 정의된(표준) \[ include 폴더 ] 에서 파일을 찾음
- `#incldue "파일명"`
	- 현재의 소스코드가 저장되어 있는 폴더를 먼저 찾고, 파일이 없다면 미리 정의된
	  \[ include 폴더 ] 에서 파일을 찾음
	- 사용자 작성 헤더
#### \[ `#inlcude` 지시어 사용 예시 ]

- `#include <stdio.h>` 
	- `stdio.h` 라는 파일의 내용을 메모리에 기억해서 원시 프로그램에 포함 시켜 
	  처리하라고 컴파일러에게 지시
	- ![[Pasted image 20250823213451.png]]

#### \[ C++ 선행처리기 추가 설명 ]
- **namespaece 사용형식**
	- ![[Pasted image 20250823213657.png]]
- C++ 컴파일러는 C 언어의 표준 함수를 모두 포함, 
  C언어의 헤더 파일명 앞에 C 를 추가하고 확장자 .h 를 생략하는 새로운 스타일을 
  정의할 수 있음
	- ![[Pasted image 20250823213838.png]]

---
### < 인터프리터 방식과 컴파일 방식 >

#### \[ 인터프리터 방식 ]

- 소스 코드의 한 라인을 읽어서 인터프리터 코드(기계코드, 이진코드)로 번역
	- **번역시간은 빠르지만**, 번역 시 실행 파일이 생성되지 않아 소스 실행을 위해 
	  인터프리터가 필요
- 소스 코드의 첫 번째 라인부터 한 라인씩 실행되므로 **프로그램의 실행 속도**가
  **컴파일러에 비해 현저히 느림**
- 인터프리토 실행 개념도
	- ![[Pasted image 20250823214300.png]]
	
#### \[ 컴파일 방식 ]

-  소스코드를 컴퓨터의 CPU 가 이해할 수 있는 기계코드(이진코드)로 변환해주는 번역기
- 소스코드를 한 번에 번역하기 때문에 **번역 속도 느림**
- 실행 파일을 생성하기 때문에 **인터프리터 방식에 비해 실행 시간이 빠름**
- 컴파일러 실행 개념도
	- ![[Pasted image 20250823214620.png]]

#### \[ 인터프리터와 컴파일 방식 피교]
 ![[Pasted image 20250823214720.png]]
	
- 컴파일러는 플랫폼(하드웨어)에 종속적 <> 인터프리터는 종속적이지 않음
# ----------------------------------------------------------
## 프로그램 개발 단계
### < 요구사항 분석 >

#### \[ 요구사항 분석이란 ]

- **문제 해결 또는 목적 달성**을 위해**사용자에게 요구**되거나, 
  **표준이나 명세 등을 만족**하기 위해 
  **시스템**이 가져야 하는 **명시적 $\cdot$ 묵시적 제약사항**을 **기술**하는 단계
- **사용자의 문제**나 **요구사항**을 **분석**하여 **수행 주체를 설정**, **환경 고려**하여 **소프트웨어에 대한 정의를 기술**하는 단계

#### \[ 요구사항 분석의 중요한 이유 ]

- **도메인 이해 부족**
	- 시스템 규모의 대상이 광범위하고, 업종 도메인 지식이 부족한 경우가 많음
- **참여자 간 이해 부족**
	- 개발자와 사용자 간에 지식이나 표현의 차이가 있어서 상호 간 이해가 부족
- **의사소통 부족**
	- 사용자와 개발자 간 업무 지식이나 용어의 불일치로 인해 의사소통이 곤란
- **지속적인 변경 요구**
	- 사용자의 **요구사항이 모호**하고 **부정확한 상태**에서 **지속적인 변경이 요구**됨

#### \[ 요구사항 분석 기법 ]

- 개발 대상에 대한 **사용자의 요구사항** 중 **명확하지 않거나 모호한 부분**을 **걸러내기** 위한 방법
- **시스템 개발, 변경의 목적**(What)을 **식별**하기 위해 **이해관계자들의 요구**를 **이해 및 조정**하여 **체계적으로 수집 $\cdot$ 분석 $\cdot$ 명세화 $\cdot$ 검증 활동**으로서 **고객의 요구에 대해 문제**(Whar)를 **이해하는 작업**
	
- ##### 요구사항 도출 기법
	- 커뮤티케이션 기반
		- 인터뷰
		- 브레인스토밍
		- 핵심그룹
		- 집단의사결정
		- 걸문조사
	- 업무분석 기반
		- 관찰(Job Shadowing)
		- 프로토타입
	- 문서 기반
		- RFI
		- RFP
		- 제안서
	
- ##### 요구사항 분석 기법
	- 쌍대 분석(AHP)
	- 페르소나
		- 가상 인물을 통해서 해당하는 요구사항에 대해 무엇이 있을 지 유추, 가설화
	- VOP
		- 전문가 판단  
	- UseCase 분석 등
	- 정적 분석 $\cdot$ 동적 분석 분류
	
- ##### 요구사항 명세 기법
	- 비정형 명세 기법
	- 정형 명세 기법(Z 명세, Petri-net)
	- 요구사항 추적 메트릭스 구성
	- 시스템 정의서
	- 요구사항 명세서
	
- ##### 요구사항 검증 기법
	- V&V
	- Peer Review(Review, Inspection, Walkthrough)
	
- ##### 요구사항 관리
	- 요구사항 협상
	- 기준선
	- 변경 관리
	- 요구사항 추적
	- 추적 메트릭 등 요구사항 모든 절차 주요 이슈 관리
	
- ##### 요구사항 분석 산출물
	- 구조적 방법
		- 자료흐름도(DFD: Data Flow Diagram)
		- 자료사전(DD: Data Dictionary)
		- 소단위명세서
		- 개체관계도
		- 상태전이도
	- 객체 지향 방법
		- UML
			- UseCase

---
### < 설계 >
#### \[ 설계단계 ]

- 요구 조건을 수행할 수 있도록 **작업의 정의 기술**과 **원리를 명세화** 하는 단계
- 요구사항 분석 단계에서 작성된 **요구사항 분석 명세서의 기능**이 **실현되도록 알고리즘**과 
  **처리될 자료 구조**를 **문서화**
- 소프트웨어 개발에 **가장 핵심이 되는 기술**로 **SW 품질 평가를 위한 지침**이이 되는 단계
#### \[ 설계 단계 활동 ]
- **상위 설계**
	- ##### 아키텍처 설계
		- 시스템 상호작용 관점에서 전체적인 구조를 나타냄
	- ##### 데이터 설계
		- 시스템에 필요한 정보를 자료 구조와 DB 설계 반영
	- ##### 시스템 분할
		- 전체 시스템을 여러 개의 서브시스템으로 분할
	- ##### 인터페이스 설계
		- 시스템의 구조와 서브시스템들 사이의 인터페이스를 명확히 정의
	- ##### 사용자 인터페이스 설계
		- 사용자가 익숙하고 편리하게 사용하도록 인터페이스 설계
- **하위 설계**
	- #####  모듈 설계
		- 각 모듈의 실제적인 내부를 알고리즘 형태로 표현
	- ##### 자료구조 설계
		- 자료구조, 변수 등에 대한 상세한 정보 작성
- 설계 활동은 **전체 공정**에서 **가장 중요**하며, **다양한 산출물**이 **작성**됨

#### \[ 소프트웨어 설계 ]

- 추상화를 통한 설계 방법을 결정
- 분할과 정복을 통해 모듈의 크기를 결정
- 모듈화를 통해 응집도 및 결합도를 결정하는 효율적인 설계 방법을 제공
- 설계 기본 원리
	- ##### 추상화(공통화)
		- 설계 방법 결정
		- 특정 목적과 관련된 **필수 정보만 추출**하여 **강조**하고 관련없는 사항을 생략함으로써 **세분화하여 구체화**하는 방법
	- ##### 분할과 정복
		- 모듈 크기 결정
		- **여러 개의 서브시스템으로 나누고** 서브시스템을 아주 **작은 시스템이나 모듈로 나누어 개발**하여 **하나씩 병합**하면서 완성시키는 방법
	- ##### 단계적 분해
		- 기능을 점점 작은 단위로 점차적으로 구체화하는 방법
		- 하향식 설계에 사용
	- ##### 모듈화
		- **응집도 및 결합도 결정**
		- 실제 개발할 수 있는 작은 단위로 나누는 것으로 **모듈은 규모가 큰 것을 여러 개로 나눈 조각**으로 **SW 구조를 이루는 기본 단위**
		- 클래스가 될 수도 있고 패키지가 될 수도 있음
- 효율적인 프로그램 구성을 지원하는 모듈화는 
  SW 개발에 있어 **기능을 분할하고 추상화**하여 **소프트웨어의 성능을 향상**시키고 
  **유지보수를 효과적**으로 하기 위한 SW 설계 및 구현 기법
- 모듈화는 **프로그램을 효율적으로 관리할 수 있도록 하는 SW 특성**으로,
  시스템을 분해하고 추상화를 통하여 SW 제품의 성능을 향상시키거나 
  **시스템의 디버깅 시험**, **통합 및 수정을 용이**하게 하는 설계 기법
	
#### \[ 소프트웨어 **응집도**(Cohesion) ]

- 정보은닉 개념의 확장 개념으로 모듈은 하나의 기능을 수행하는 집적성을 지칭
- **하나의 모듈**이 **하나의 기능**을 온전히 순도 높게 **담당하고 있는 정도**
- 응집도는 **높을수록 좋음**
- 응짐도의 정도 
	- **기능적** > **순차적** > **통신적** > **절차적** > **시간적** > **논리적** > **우연적**
-  ![[Pasted image 20250823223144.png]]

#### \[ 소프트웨어 결합도(Coupling) ]
- 소프트웨어 구조에서 모듈 간의 관련성을 측정하는 척도
- 모듈들 간의 서로 다른 책임이 얽혀 있어서 상호 의존도가 높은 정도를 의미
- 결합도는 낮을수록 좋음
- 결합의 정도
	- 내용 > 공통 >  외부 > 제어 > 스탬프 > 자료
- ![[Pasted image 20250823224115.png]]
	
- 좋은 소프트웨어의 설계 조건은 **모듈간 결합도는 낮게, 응집도는 높게 설계**하여 
  모듈의 독립성을 높이는 것

---
### < 코딩 >

#### \[ 코딩 단계]

- 설계 단계에서 생성된 결과를 실제로 활용할 수 있도록 프로그래밍
	- 설계 단계에서 작성한 산출물 토대로 실제 사용할 수 있도록 변환하는 과정
- 코딩을 위한 언어
	- 프로젝트 성격, 서비스 대상, 대상 업부, 개발자 경험을 토대로 선정
	- C, C++, JAVA 등 프로그래밍 언언 중 하나는 선택하여 코딩
- 코딩 - 프로그래밍 - 소프트웨어 개발 정의
	- ![[Pasted image 20250824000014.png]]
- 좋은 소프트웨어를 개발하기 위한 요건
	- **개발 가이드**를 통해 **개발팀에게 먼저 교육**이 진행
	-  **공통기능과 템플릿**을 통해서 **개발 표준을 정하는 것**이 필요
	- 설계된 명세서에 따라 실행 가능한 소스코드를 작성하고 **인스펙션을 수행**
	- **단위테스트**를 통해 **품질 향상 및 완전성 검증**
- 코딩 단계에서 고려할 사항
	- 코딩 작업시 명명규칙, 주석 표준, 에러 메시지 표준 등의 **개발 표준을 작성**하여 준수
	- **형상 관리 툴**을 이용하여 **버전 관리 및 백업 관리**를 하는 것
	- 코드 인스펙션 툴을 개발자 PC에 설치하여 **개발자가 자체적으로 상시 코드 점검**을 할 수 있는 환경을 구성하고, 소스코드를 통합하여 배포함으로써 **기능 완성도를 수시로 체크**

---
### < 디버깅 및 테스팅 >

#### \[ 디버깅 ]

- **프로그램**의 **오류를 발견**하고 그 **원인을 밝히는 작업** 과정
- ##### 테이블 디버깅
	- 프로그래머가 **직접 손으로 체크해서 눈으로 확인**하는 방법
- ##### 컴퓨터 디버깅
	- **디버깅 소프트웨어를 이용**하는 방식

#### \[ 테스팅 ]

- 노출되지 않은 **숨은 결함**을 찾기 위해 **프로그램을 실행**하여 **품질을 평가**하는 과정
- ##### 단위테스트
	- **모듈** 단위로 적절한 **기능**을 가지고 있는지 **확인**하는 테스트
	- 코딩이 이루어진 후 **모듈에 초점을 맞추어 검사**
- #### 통합테스트
	- **모듈이 통합**되었을 때 잘 **작동**하는 지를 검서
	- **모듈 단위로 단계적으로 통합**하면서 **검사**

#### \[ 디버깅과 테스트 차이 ]

- 디버깅이 오류에 대한 수정 작업이라면, 테스팅은 결함을 발견하는 작업
- ##### 디버깅
	- 컴퓨터 소프트웨어 또는 시스템의 올바른 작동을 방해하는 **컴퓨터 프로그램 내의 결함** 또는 문제점을 **찾아 해결**하는 것
- ##### 테스트
	- **실제 결과가 소프트웨어의 예상 결과와 일치하는지 여부**를 확인하고 
	  **결함이 없는지 확인**하는 활동
	- 보통 개발자가 개발한 이후 디버깅을 하기 때문에 프로젝트 공정상 
	  **테스트가 더 중요한 절차**
- ![[Pasted image 20250824004147.png]]
	
- 테스팅은 기존 조건 및 필요조건(결함, 에러, 버그) 사이의 차이점을 발견하기 위하여 
  소프트웨어 항목을 분석하고, 분석된 항목의 특성을 평가하는 프로세스로 
  IEEE-829 에 규정되어 있음
- 소프트웨어 테스트
	- 개발된 소프트웨어의 숨겨진 결함과 문제를 식별
	- 품질을 평가
	- 품질을 개선하기 위한 일련의 활동
	- 소프트웨어 테스트 원리
		- ##### 테스팅은 결함이 존재함을 밝히는 활동
			- 테스팅은 소프트웨어에 잠재적으로 존재하는 결함을 줄일 수는 있지만, 
			  결함이 전혀 발견되지 않는 경우라도 해당 소프트웨어에 결함이 없다고 
			  증명할 수는 없음
		- ##### 완변학 테스트(Exhaustive Testing)는 불가능
			- 무한 경로, 무한 입력 값, 무한 타이밍 등으로 인해 블가능
			- 테스트 대상의 리스크를 토대로 테스트 활동 노력 차별화
		- ##### 테스팅은 개발 초기에 시작
			- 개발의 시작과 동시에 테스트를 계획하고 전략적으로 접근하는 것을 고려하는 것은 물로, 요구사항 분석서와 설계서 등의 개발 산출물을 분석하여 테스트 케이스를 도출하는 과정을 통해 결함을 발견
		- ##### 결합 집중(Defect Clustering)
			- 출시 전 대다수의 결함들은 소수의 특정 모듈에 집중되어 발생하는 
			  경향을 보임
		- ##### 살충제 패러독스(Pesticicde Paradox)
			- 동일한 테스트 케이스로 동일한 테스트를 반복적으로 수행하면,
			  테스트 내성으로 인해 더 이상 새로운 결함을 찾아내지 못함
			- 테스트 케이스를 정기적으로 리뷰하고 개선 필요
		- ##### 테스팅은 정황(Context)에 의존
			- 정황과 비즈니스 도메인(분야)에 따라 다르게 테스트를 수행해야 함
		- ##### 오류 - 부재의 궤변
			- 사용자 또는 비즈니스의 요구사항을 충족시키지 못한다면,
			  설사 결함을 모두 발견하여 제거 하였다고 하더라도 품질이 높다고 볼 수 없음