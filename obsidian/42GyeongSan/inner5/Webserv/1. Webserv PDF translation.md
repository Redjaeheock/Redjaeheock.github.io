
### This is when you finally understand why URLs start with HTTP

- _'이때 비로소 URL이 HTTP로 시작하는 이유를 이해하게 된다'

#### Summary

This project is about writing your own HTTP server. 
You will be able to test it with an actual browser. 
HTTP is one of the most widely used protocols on the internet. 
Understanding its intricacies will be useful, even if you won’t be working on a website.

- _이 프로젝트는 자신만의 HTTP 서버를 작성하는 것에 관한 것이다.
- _실제 브라우저로 테스트할 수 있다.
- _HTTP는 인터넷에서 가장 널리 사용되는 프로토콜 중 하나이다.
- _웹사이트에서 작업하지 않더라도 HTTP의 복잡성을 이해하는 것이 유용할 것이다._
---
#### Introdustion

The Hypertext Transfer Protocol (HTTP) is an application protocol for distributed, collaborative, hypermedia information systems.

- _하이퍼텍스트 전송 프로토콜(HTTP)은 분산, 협업, 하이퍼미디어 정보 시스템을 위한
  응용 프로토콜이다.  

HTTP is the foundation of data communication for the World Wide Web, where hypertext documents include hyperlinks to other resources that the user can easily access.
For example, by clicking a mouse button or tapping the screen on a web browser.

- _HTTP는 사용자가 쉽게 액세스할 수 있는 다른 리소스와의 하이퍼텍스트 문서에 
  하이퍼링크가 포함되어 있는 월드 와이드 웹의 데이터 통신의 기초다.
- _예를 들어, 마우스 버튼을 클릭하거나 웹 브라우저의 화면을 탭하여 사용할 수 있다.

HTTP was developed to support hypertext functionality and the growth of the World Wide Web.

- _HTTP는 하이퍼텍스트 기능과 월드 와이드 웹의 성장을 지원하기 위해 개발되었다.

The primary function of a web server is to store, process, and deliver web pages to clients. Client-server communication occurs through the Hypertext Transfer Protocol (HTTP).

- _웹 서버의 주요 기능은 웹 페이지를 저장, 처리 및 클라이언트에게 전달하는 것이다.  
- _클라이언트와 서버 간의 통신은 하이퍼텍스트 전송 프로토콜(HTTP)을 통해 이루진다.

Pages delivered are most frequently HTML documents, which may include images, style sheets, and scripts in addition to the text content.

- _전달되는 페이지는 대부분 HTML 문서로, 텍스트 내용 외에도 이미지, 스타일 시트, 스크립트 등이 포함될 수 있다.

Multiple web servers may be used for a high-traffic website, splitting traffic between multiple physical machines.

- _트래픽이 많은 웹사이트에서는 여러 웹 서버를 사용하여 여러 물리적 기기 간에 트래픽을
  분산시킬 수 있다.

A user agent, commonly a web browser or web crawler, initiates communication by requesting a specific resource using HTTP, and the server responds with the content of that resource or an error message if unable to do so.
The resource is typically a real file on the server’s storage, or the result of a program. 
But this is not always the case and can actually be many other things.

- _사용자 에이전트(일반적으로 웹 브라우저 또는 웹 크롤러)는 HTTP를 사용하여 특정 리소스를 요청하여 통신을 시작하고, 서버는 해당 리소스의 내용이나 오류 메시지로 응답이다.
- _이 리소스는 일반적으로 서버 저장소의 실제 파일이거나 프로그램의 결과다. 
- _하지만 항상 그런 것은 아니며 실제로는 다른 많은 것들이 있을 수 있다.

Although its primary function is to serve content, HTTP also enables clients to send data.
This feature is used for submitting web forms, including the uploading of files.

- _HTTP의 주요 기능은 콘텐츠를 서비스하는 것이지만, 클라이언트도 데이터를 전송할 수 있다.
- _이 기능은 파일 업로드를 포함한 웹 양식을 제출하는 데 사용된다.
---

#### Mandatory part

##### Program Name
- webserv
##### Files to Submit
- Makefile
- \*.{h, hpp}
- \*.cpp
- \*.tpp
- \*.ipp
- configuration files
##### Makefile
- NAME
- all
- clean
- fclean
- re
##### Arguments
- \[ A configuration file ]
##### Externel Function
- All functionality must be implemented in C++ 98.
- execve, pip, strerror, gai_strerror, errno, dup, dup2, fork
- socketpair, htons, htonl, ntohs, ntohl
- select, poll, epoll(epoll_create, epoll_ctl, epoll_wait)
- kqueue(kqueue, kevent), socket, accept, listen, send
- chdir, bind, connect, getaddrinfo, freeaddrinfo, setsockpt
- getsockname, getprotobyname, fcntl, close, read, write, waitpid
- kill, signal, access, stat, open, opendir, readdir, closedir
##### Libft authorized
- n/a
##### Description
- An HTTP server in C++ 98

You must write an HTTP server in C++98.

Your executable should be executed as follows:
- ./webserv \[configuration file]

##### Tip ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`Even through poll() is mentioned in the subject and evaluation sheet,
`you can use any equivalent function as select(), kqueue() or epoll().

- _주제와 평가지에 poll()이 언급되어 있어도 select(), kqueue() 또는 epoll()과 같은 동등한 함수를 사용할 수 있습니다.
##### ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
##### Warning ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Please read the RFCs defining the HTTP protocol, and perform tests with telnet and NGINX before starting this project. Although you are not required to implement the entire RFCs, reading it will help you develop the required features. The HTTP 1.0 is suggested as a reference point, but not enforced.

- _이 프로젝트를 시작하기 전에 HTTP 프로토콜을 정의하는 RFC를 읽고 telnet과 NGINX로 
  테스트를 수행해 주세요.
- _전체 RFC를 구현할 필요는 없지만, 이를 읽으면 필요한 기능을 개발하는 데 도움이 됩니다.
- _HTTP 1.0이 기준점으로 제안되었지만 강제되지는 않았습니다._
##### ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
---
#### Requirements

Your program must use a configuration file, provided as an argument on the command line, or available in a default path.

- _프로그램은 명령줄에 인수로 제공되거나 기본 경로로 제공되는 구성 파일을 사용해야 합니다.

You cannot execve another web server.

- _다른 웹 서버를 실행할 수 없습니다.

Your server must remain non-blocking at all times and properly handle client disconnections when necessary.

- _서버는 항상 차단하지 않고 필요할 때 클라이언트 연결을 적절히 처리해야 합니다.

It must be non-blocking and use only 1 poll() (or equivalent) for all the I/O operations between the clients and the server (listen included).

- _차단되지 않아야 하며 클라이언트와 서버 간의 모든 I/O 작업에 대해 1개의 poll()(또는 동등한)만 사용해야 합니다(청취 포함).

poll() (or equivalent) must monitor both reading and writing simultaneously.

- _poll()(또는 이에 상응하는)는 읽기와 쓰기를 동시에 모니터링해야 합니다.

You must never do a read or a write operation without going through poll() (or equivalent).

- _절대로 poll()(또는 동등한 것)을 거치지 않고 읽기나 쓰기 작업을 해서는 안 됩니다.

Checking the value of errno to adjust the server behaviour is strictly forbidden after performing a read or write operation.

- _읽기 또는 쓰기 작업을 수행한 후 서버 동작을 조정하기 위해 오류 값을 확인하는 것은 엄격히 금지됩니다.

You are not required to use poll() (or an equivalent function) for regular disk files; read() and write() on them do not require readiness notifications.

- _일반 디스크 파일에는 poll()(또는 이에 상응하는 함수)를 사용할 필요가 없으며, 읽기()와 쓰기()는 준비 알림이 필요하지 않습니다
##### Warning ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
I/O that can wait for data (sockets, pipes/FIFOs, etc.) must be non-blocking and driven by 
a single poll() (or equivalent). 
Calling read/recv or write/send on these descriptors without prior readiness will result in 
a grade of 0. 
Regular disk files are exempt.

- _데이터(socket, pipes/FIFOs 등)를 기다릴 수 있는 입출력은 차단되지 않고 
  단일 poll()(또는 이에 상응하는)에 의해 구동되어야 합니다.  
- _사전 준비 없이 읽기/회신 또는 쓰기/전송 descriptor 를 호출하면 0점이 됩니다.  
- _일반 디스크 파일은 면제됩니다.
##### ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

When using poll() or any equivalent call, you can use every associated macro or helper function (e.g., FD_SET for select()).

- _poll() 또는 이에 상응하는 호출을 사용할 때는 모든 관련 매크로 또는 헬퍼 함수(예: select())를 사용할 수 있습니다.

A request to your server should never hang indefinitely.

- _서버에 대한 요청은 절대 무기한으로 중단되어서는 안 됩니다.

Your server must be compatible with standard web browsers of your choice.

- _서버는 원하는 표준 웹 브라우저와 호환되어야 합니다.

NGINX may be used to compare headers and answer behaviours
(pay attention to differences between HTTP versions).

- _NGINX는 헤더와 응답 동작을 비교하는 데 사용될 수 있습니다
  (HTTP 버전 간의 차이점에 주의하세요).

Your HTTP response status codes must be accurate.

- _HTTP 응답 상태 코드는 정확해야 합니다

Your server must have default error pages if none are provided.

- _서버에 기본 오류 페이지가 제공되지 않는 경우 서버에 오류 페이지가 있어야 합니다.

You can’t use fork for anything other than CGI (like PHP, or Python, and so forth).

- _CGI 외에는 포크를 사용할 수 없습니다(예: PHP, 파이썬 등).

You must be able to serve a fully static website.

- _완전히 정적인 웹사이트를 제공할 수 있어야 합니다.

Clients must be able to upload files.

- _클라이언트는 파일을 업로드할 수 있어야 합니다.

You need at least the GET, POST, and DELETE methods.

- _최소한 GET, POST, DELETE methods 가 필요합니다.

Stress test your server to ensure it remains available at all times.

- _서버가 항상 사용 가능한지 확인하려면 스트레스 테스트를 하세요.

Your server must be able to listen to multiple ports to deliver different content 
(see Configuration file).

- _서버가 다양한 콘텐츠를 제공하려면 여러 포트를 들을 수 있어야 합니다
  (구성 파일 참조).

##### Warning ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
We deliberately chose to offer only a subset of the HTTP RFC. In this context, the virtual host feature is considered out of scope. But you are allowed to implement it if you want.

- _저희는 의도적으로 HTTP RFC의 일부만 제공하기로 결정했습니다. 
- _이 맥락에서 가상 호스트 기능은 범위를 벗어난 것으로 간주됩니다. 하지만 원하시면 구현할 수 있습니다._
##### ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
---
#### For MacOS only

##### Tip ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Since macOS handles write() differently from other Unix-based OSes, you are allowed to use fcntl().
You must use file descriptors in non-blocking mode to achieve behaviour similar to that of other Unix OSes

- _macOS는 다른 유닉스 기반 OS와 쓰기()를 다르게 처리하기 때문에 fcntl()을 사용할 수 있습니다.
- _다른 유닉스 OS와 유사한 동작을 수행하려면 비차단 모드에서 file descriptors 를 사용해야 합니다
##### ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

##### Warning ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
However, you are allowed to use fcntl() only with the following flags:
- F_SETFL, O_NONBLOCK and, FD_CLOEXEC.
Any other flag is forbidden.

- _그러나 fcntl()는 다음 플래그와 함께만 사용할 수 있습니다:
	- F_SETFL, O_NONBLOCK, 그리고 FD_CLOEX.
- _다른 플래그는 금지되어 있습니다._
##### ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
---
#### Configuration file

In the configuration file, you should be able to:
- Define all the interface:port pairs on which your server will listen to (defining multiple websites served by your program).
- Set up default error pages.
- Set the maximum allowed size for client request bodies.
- Specify rules or configurations on a URL/route (no regex required here), for a website, among the following:
	- List of accepted HTTP methods for the route.
	- HTTP redirection.
	- Directory where the requested file should be located (e.g., if URL /kapouet is rooted to /tmp/www, URL /kapouet/pouic/toto/pouet will search for /tmp/www/pouic/toto/pouet).
	- Enabling or disabling directory listing.
	- Default file to serve when the requested resource is a directory.
	- Uploading files from the clients to the server is authorized, and storage location is provided.
	- Execution of CGI, based on file extension (for example .php). Here are some specific remarks regarding CGIs:
		- Do you wonder what a CGI is?
		- Have a careful look at the environment variables involved in the web server-CGI communication. The full request and arguments provided by the client must be available to the CGI.
		- Just remember that, for chunked requests, your server needs to un-chunkthem, the CGI will expect EOF as the end of the body.
		- The same applies to the output of the CGI. If no content_length is returned from the CGI, EOF will mark the end of the returned data.
		- The CGI should be run in the correct directory for relative path file access.
		- Your server should support at least one CGI (php-CGI, Python, and soforth).

_구성 파일에서 다음을 수행할 수 있어야 합니다:  
- _서버가 들을 모든 인터페이스:포트 쌍을 정의합니다(프로그램에서 제공하는 여러 웹사이트를 정의합니다).  
- _기본 오류 페이지를 설정합니다.  
- _클라이언트 요청 기관에 허용되는 최대 크기를 설정합니다.  
- _웹사이트의 URL/경로에 대한 규칙이나 구성(여기서는 정규 표현이 필요하지 않음)을 다음 중에서 지정합니다:
	- _경로에 대해 허용된 HTTP 메서드 목록.  
	- _HTTP 리디렉션.  
	- _요청된 파일이 위치해야 하는 디렉토리
	  (예: URL /kapouet가 /tmp/www에 루트가 있는 경우 URL /kapouet/pouic/to/pouet는
	  /tmp/www/pouic/to/pouet를 검색합니다).  
	- _디렉토리 목록을 활성화하거나 비활성화합니다.  
	- _요청된 리소스가 디렉토리일 때 사용할 기본 파일입니다.  
	- _클라이언트에서 서버로 파일을 업로드하는 것이 승인되었으며 저장 위치가 제공됩니다.  
	- _파일 확장자(예: .php)를 기반으로 한 CGI 실행. 다음은 CGI에 관한 몇 가지 구체적인 언급입니다:
		- _CGI가 무엇인지 궁금하십니까?  
		- _웹 서버-CGI 통신과 관련된 환경 변수를 주의 깊게 살펴보세요. 클라이언트가 제공한 전체 요청과 인수는 CGI가 이용할 수 있어야 합니다.  
		- _청크된 요청의 경우 서버가 청크 해제해야 하며, CGI는 EOF를 본체의 끝으로 예상합니다.  
		- _CGI의 출력에도 동일하게 적용됩니다. CGI에서 content_length가 반환되지 않으면 EOF는 반환된 데이터의 끝을 표시합니다.  
		- _상대 경로 파일 접근을 위해 CGI는 올바른 디렉토리에서 실행되어야 합니다.  
		- _서버는 최소한 하나의 CGI(php-CGI, Python 등)를 지원해야 합니다.


You must provide configuration files and default files to test and demonstrate that every feature works during the evaluation.

- _평가 중에 모든 기능이 작동하는지 테스트하고 입증하려면 구성 파일과 기본 파일을 제공해야 합니다.  
  
You can have other rules or configuration information in your file (e.g., a server name for a website if you plan to implement virtual hosts).

- _파일에 다른 규칙이나 구성 정보를 포함할 수 있습니다(예: 가상 호스트를 구현할 계획인 경우 웹사이트의 서버 이름)._
##### Tip ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
If you have a question about a specific behaviour, you can compare your program’s behaviour with NGINX’s.
We have provided a small tester. Using it is not mandatory if everything works fine with your browser and tests, but it can help you find and fix bugs.

- _특정 행동에 대해 질문이 있으시면, 프로그램의 행동을 NGINX의 행동과 비교할 수 있습니다.  
- _작은 테스터를 제공했습니다. 브라우저와 테스트에서 모든 것이 정상적으로 작동하는 경우 사용이 필수는 아니지만 버그를 찾고 수정하는 데 도움이 될 수 있습니다.
##### ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

##### Warning ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Resilience is key. Your server must remain operational at all times.

- _회복력이 중요합니다. 서버는 항상 운영 상태를 유지해야 합니다.
##### ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

##### Warning ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Do not test with only one program. Write your tests in a more suitable language, such as Python or Golang, among others, even in C or C++ if you prefer.

- _하나의 프로그램으로만 테스트하지 마세요. 원한다면 Python이나 Golang 등 더 적합한 언어로 테스트를 작성하고 C 또는 C++로 작성하세요_
##### ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
---
#### Bonus part

Here are some additional features you can implement:
- Support cookies and session management (provide simple examples).
- Handle multiple CGI types.

_다음은 구현할 수 있는 몇 가지 추가 기능입니다:  
- _쿠키와 세션 관리를 지원합니다(간단한 예시 제공).  
- 여러 CGI 유형을 처리합니다._
##### Warning ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
The bonus part will only be assessed if the mandatory part is fully completed without issues. 
If you fail to meet all the mandatory requirements, your bonus part will not be evaluated.

- _보너스 부분은 필수 부분이 문제 없이 완전히 완료된 경우에만 평가됩니다.  
- _모든 필수 요건을 충족하지 못하면 보너스 부분은 평가되지 않습니다._
##### ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

